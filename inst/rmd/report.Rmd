---
title: "Report Template for CGR Telomere Analysis"
output: html_document
params:
  input.path: ""
  output.path: ""
  project.id: ""
  plate.content.report: ""
  plate.list: ""
  final.tsv: ""
  infer.384.locations: FALSE
  subject.list.from.input.path: TRUE
---

---
# Set global ggplot2 theme
---

```{r ggplottheme, eval=TRUE, echo=FALSE}
my.theme <- ggplot2::theme_light() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(size = 14, hjust = 0.5),
    axis.title = ggplot2::element_text(size = 12),
    axis.text = ggplot2::element_text(size = 10),
    legend.title = ggplot2::element_text(size = 12),
    legend.text = ggplot2::element_text(size = 10),
    strip.background = ggplot2::element_blank(),
    strip.text = ggplot2::element_text(size = 12, colour = "black")
  )
```

---
# Make sure required output directory structure exists
---

```{r create.output.directories, eval=TRUE, echo=FALSE}
## if output directory path does not exist, create it
create.output.directories(output.path)
```


---
# Detect input files based on fixed input directory structure
---

```{r find.input.files, eval=TRUE, echo=FALSE}
## aggregate pairs of filenames from input.path/Data/Exports
input.files <- find.input.files(paste(input.path, "Data",
  "Exports",
  sep = "/"
))
```


---
# Load data from detected input files
---

```{r load.exported.data, eval=TRUE, echo=FALSE}
## load data from acquired pairs of files
input.data <- lapply(input.files, function(i) {
  read.export.datum(i,
    source.search.path = paste(input.path,
      "Data",
      "Analysis",
      sep = "/"
    ),
    subject.list.from.input.path = subject.list.from.input.path,
    plate.content.report = plate.content.report,
    plate.list = plate.list
  )
})
```

---
# Run primary analysis generation on loaded data
---

```{r run.primary.analysis, eval=TRUE, echo=FALSE}
## run primary analysis steps for Data/Analysis
primary.analysis <- lapply(input.data, function(i) {
  create.analysis(i,
    plate.content.report = plate.content.report,
    plate.list = plate.list,
    infer.384.locations = infer.384.locations
  )
})
```

---
# Report primary analysis results to file
---

```{r report.primary.analysis, eval=TRUE, echo=FALSE}
## report the primary analysis results to the output/Data/Analysis
lapply(primary.analysis, function(i) {
  report.primary.analysis(i, output.path, project.id)
})
```

---
# Report final summary table
---
```{r report.final.table, eval=TRUE, echo=FALSE}
## report the final summary table of combined data across primary analyses
res <- rbind()
for (i in 1:length(primary.analysis)) {
  res <- rbind(
    res,
    format.final.analysis(
      primary.analysis[[i]],
      project.id
    )
  )
}
res <- res[!is.na(res[, "Vial ID"]) &
  !is.na(res[, "Sample ID"]), ]
write.table(res,
  final.tsv,
  row.names = FALSE,
  col.names = TRUE,
  quote = FALSE,
  sep = "\t"
)
```

---
# Compute ICC
---
```{r icc, eval=TRUE, echo=FALSE}
## extract subject dups only
res.dups <- res[res[, "Vial ID"] != "NA07057" &
  res[, "Sample ID"] != "NTC", ]
completion.rate <- length(which(!is.na(res.dups[, "Standardized T/S Ratio"])))
completion.rate <- completion.rate / nrow(res.dups) * 100
telo.cv <- mean(res.dups[, "Telo %CV"], na.rm = TRUE)
control.cv <- mean(res.dups[, "36B4 %CV"], na.rm = TRUE)
unique.study.samples <- length(unique(res.dups[, "Sample ID"]))
res.dups <- res.dups[duplicated(res.dups[, "Sample ID"]) |
  duplicated(res.dups[, "Sample ID"], fromLast = TRUE), ]
n.tech.reps <- length(unique(res.dups[, "Sample ID"]))
## compute ICC to match existing method
ICC.est <- ICC::ICCest(
  factor(res.dups[, "Sample ID"]),
  res.dups[, "Standardized T/S Ratio"]
)
```

---
# Report first summary blob
---

## Samples

A total of `r unique.study.samples` unique study samples were run 
in this project. CGR Internal Controls (NA07057) were added to five
of those wells and water (NTC) was added to one of those wells.
A total of `r nrow(res)` sample instances in the project were tested
across `r length(unique(res[, "Intermediate Source Plate ID"]))`
sets of plates.

 - Overall completion rate of study samples: 
   `r round(completion.rate, 2)`%
 - Average %CV for Telo assay triplicates:
   `r round(telo.cv, 3)`%
 - Average %CV for 36B4 assay triplicates:
   `r round(control.cv, 3)`%
 - Technical replicates in project (n=`r n.tech.reps`), 
   `r round(n.tech.reps/unique.study.samples*100,1)`%

---
# Compute information about internal controls
---

```{r internal.controls, eval=TRUE, echo=FALSE}
res.int <- res[res[, "Vial ID"] == "NA07057", ]
mean.cv <- mean(res.int[, "Telo %CV"], na.rm = TRUE)
box.data <- data.frame(
  x = factor(rep(res.int[, "Intermediate Source Plate ID"], 2)),
  y = c(
    res.int[, "Raw T/S Ratio"],
    res.int[, "Standardized T/S Ratio"]
  ),
  outtype = rep(c(
    "Raw T/S Ratio",
    "Standardized T/S Ratio"
  ),
  each = nrow(res.int)
  )
)
cv.box <- ggplot2::ggplot(ggplot2::aes(
  x = .data$x,
  y = .data$y,
  outtype = .data$outtype
),
data = box.data
)
cv.box <- cv.box + my.theme
cv.box <- cv.box + ggplot2::geom_boxplot(ggplot2::aes(
  x = .data$x,
  y = .data$y
))
cv.box <- cv.box + ggplot2::geom_jitter(
  shape = 16,
  position = ggplot2::position_jitter(0.2)
)
cv.box <- cv.box + ggplot2::scale_y_continuous(
  limits = c(0, 3),
  breaks = seq(0, 3, 0.5)
)
cv.box <- cv.box + ggplot2::theme(
  axis.text.x =
    ggplot2::element_text(
      size = 10,
      angle = 90
    )
)
cv.box <- cv.box + ggplot2::xlab("Intermediate Source Plate ID")
cv.box <- cv.box + ggplot2::ylab("")
cv.box <- cv.box + ggplot2::facet_grid(.data$outtype ~ .)
```

---
# Report on internal controls
---

## Internal Controls

The CGR Internal Control, which is used to standardize the raw T/S ratios for all samples
within each plate of the project, had an overall CV of `r round(mean.cv, 3)`%.

---
# Render the CV boxplot
---

```{r render.cv.boxplot, eval=TRUE, echo=FALSE}
print(box.data)
print(cv.box)
```

---
# Compute information on technical replicates
---

```{r compute.techrep, eval=TRUE, echo=FALSE}
techrep.data <- data.frame(
  y = res.dups[, "Standardized T/S Ratio"],
  x = res.dups[, "Sample ID"]
)
## assign each sample its average value for plotting
tech.samples <- unique(techrep.data$x)
tech.values <- c()
for (id in tech.samples) {
  tech.values <- c(
    tech.values,
    mean(techrep.data[techrep.data$x == id, "y"],
      na.rm = TRUE
    )
  )
}
tech.samples <- tech.samples[order(tech.values)]
techrep.data$x <- factor(techrep.data$x, levels = tech.samples)
techrep.plot <- ggplot2::ggplot(ggplot2::aes(
  x = .data$x,
  y = .data$y
),
data = techrep.data
)
techrep.plot <- techrep.plot + my.theme
techrep.plot <- techrep.plot + ggplot2::theme(axis.text.x = ggplot2::element_blank())
techrep.plot <- techrep.plot + ggplot2::geom_point()
techrep.plot <- techrep.plot + ggplot2::xlab("")
techrep.plot <- techrep.plot + ggplot2::ylab("Standardized T/S Ratio")
```

---
# Report on Technical Replicates
---

The distribution of standardized T/S ratios from the technical replicates
between plates can be seen below. The intraclass correlation coefficient (ICC)
and its 95% confidence interval were `r round(ICC.est$ICC, 3)` 
(`r round(ICC.est$LowerCI, 3)`,`r round(ICC.est$UpperCI, 3)`).


---
# Render the technical replicate scatterplot
---

```{r render.techrep.scatterplot, eval=TRUE, echo=FALSE}
print(techrep.plot)
```
